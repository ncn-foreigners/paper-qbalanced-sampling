quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## quantile balancing
sample2 <- BalancedSampling::cube(prob = pop_data$pik, x = cbind(X,Xs))
## without calibration
pop_data_sample2 <- copy(pop_data[sample2])
pop_data_sample2[, g:=1]
sample_qcal <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
library("data.table")
library("jointCalib") ## joint_calib_create_matrix
library("sampling") ## data and inclusionprobabilities
library("BalancedSampling") ## BalancedSampling::cube (faster than sampling)
library("SamplingBigData") ## BalancedSampling::lpm2_kdtree
library("laeken") ## weightedMean and weightedQuantile
library("xtable") ## xtable
seed_number <- 2024-7-22
set.seed(seed_number)
N <- 100000
n <- 500
x1 <- rnorm(N,1,1)
x2 <- rexp(N,1)
alp <- rnorm(N)
epsilon <- rnorm(N)
y11 <- 1 + x1 + x2 + alp + epsilon
y12 <- 0.5*(x1-1.5)^2 + x2^2 + alp + epsilon
y21 <- rbinom(N,1,plogis(1 + x1 + x2 + alp))
y22 <- rbinom(N,1,plogis(0.5*(x1-1.5)^2 + x2^2 + alp))
pop_data <- data.table(x1,x2,y11,y12,y21,y22)
pop_data[, pik:=n/N]
#p_quantiles1 <- seq(0.25, 0.75, 0.25)
p_quantiles1 <- seq(0.10, 0.90, 0.10)
probs_est <- 0.9
vars_est <- c("y11", "y12", "y21", "y22")
X <- as.matrix(pop_data[, .(x1, x2)])
pop_quantiles <- list(x1=quantile(pop_data$x1, p_quantiles1),
x2=quantile(pop_data$x2, p_quantiles1))
Xs <- joint_calib_create_matrix(X_q = X,
N = N,
pop_quantiles = pop_quantiles)
# population means and medians
trues <- pop_data[, lapply(.SD, function(x) c(mean = mean(x),
median = median(x),
quantile = quantile(x, probs = probs_est),
sum = sum(x))),
.SDcols = vars_est][, type:=c("mean", "median", "quantile", "total")] |>
melt(id.vars = "type", value.name = "true")
R <- 100
results <- list()
for (r in 1:R) {
set.seed(r)
if (r %% 10 == 0) print(r)
## standard balancing sampling
sample1 <- BalancedSampling::cube(prob = pop_data$pik,  x = X)
## without calibration
pop_data_sample1 <- copy(pop_data[sample1])
pop_data_sample1[, g:=1]
sample_cal <- pop_data_sample1[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## with calibration
g <- calib(Xs = model.matrix(~ x1 + x2, pop_data_sample1),
d = 1/pop_data_sample1$pik,
total = c(N, colSums(X)),
method = "raking")
pop_data_sample1[, g1:=g]
sample_cal2 <- pop_data_sample1[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g1/pik),
median = weightedMedian(x = x, weights = g1/pik),
quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## quantile balancing
sample2 <- BalancedSampling::cube(prob = pop_data$pik, x = cbind(X,Xs))
## without calibration
pop_data_sample2 <- copy(pop_data[sample2])
pop_data_sample2[, g:=1]
sample_qcal <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## with calibration
g <- joint_calib(formula_totals =  ~ x1 + x2,
formula_quantiles = ~ x1 + x2,
data = pop_data_sample2,
dweights = 1/pop_data_sample2$pik,
N = N,
pop_totals = colSums(X),
pop_quantiles = pop_quantiles,
method = "raking")
pop_data_sample2[, g1:=g$g]
sample_qcal2 <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g1/pik),
median = weightedMedian(x = x, weights = g1/pik),
quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
results[[r]] <- rbind(sample_cal, sample_cal2, sample_qcal, sample_qcal2)
}
g <- joint_calib(formula_totals =  ~ x1 + x2,
formula_quantiles = ~ x1 + x2,
data = pop_data_sample2,
dweights = 1/pop_data_sample2$pik,
N = N,
pop_totals = colSums(X),
pop_quantiles = pop_quantiles,
method = "raking")
g
## standard balancing sampling
sample1 <- BalancedSampling::cube(prob = pop_data$pik,  x = X)
## without calibration
pop_data_sample1 <- copy(pop_data[sample1])
pop_data_sample1[, g:=1]
sample_cal <- pop_data_sample1[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## with calibration
g <- calib(Xs = model.matrix(~ x1 + x2, pop_data_sample1),
d = 1/pop_data_sample1$pik,
total = c(N, colSums(X)),
method = "raking")
pop_data_sample1[, g1:=g]
sample_cal2 <- pop_data_sample1[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g1/pik),
median = weightedMedian(x = x, weights = g1/pik),
quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## quantile balancing
sample2 <- BalancedSampling::cube(prob = pop_data$pik, x = cbind(X,Xs))
## without calibration
pop_data_sample2 <- copy(pop_data[sample2])
pop_data_sample2[, g:=1]
sample_qcal <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
g <- joint_calib(formula_totals =  ~ x1 + x2,
formula_quantiles = ~ x1 + x2,
data = pop_data_sample2,
dweights = 1/pop_data_sample2$pik,
N = N,
pop_totals = colSums(X),
pop_quantiles = pop_quantiles,
method = "raking")
pop_data_sample2[, g1:=g$g]
g <- joint_calib(formula_totals =  ~ x1 + x2,
formula_quantiles = ~ x1 + x2,
data = pop_data_sample2,
dweights = 1/pop_data_sample2$pik,
N = N,
pop_totals = colSums(X),
pop_quantiles = pop_quantiles,
method = "raking")$g
pop_data_sample2[, g1:=g]
gcal <- joint_calib(formula_totals =  ~ x1 + x2,
formula_quantiles = ~ x1 + x2,
data = pop_data_sample2,
dweights = 1/pop_data_sample2$pik,
N = N,
pop_totals = colSums(X),
pop_quantiles = pop_quantiles,
method = "raking")
pop_data_sample2[, g1:=gcal$g]
gcal
## quantile balancing
sample2 <- BalancedSampling::cube(prob = pop_data$pik, x = cbind(X,Xs))
## without calibration
pop_data_sample2 <- copy(pop_data[sample2])
pop_data_sample2[, g:=1]
sample_qcal <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
gcal <- joint_calib(formula_totals =  ~ x1 + x2,
formula_quantiles = ~ x1 + x2,
data = pop_data_sample2,
dweights = 1/pop_data_sample2$pik,
N = N,
pop_totals = colSums(X),
pop_quantiles = pop_quantiles,
method = "raking")
pop_data_sample2[, g1:=gcal$g]
sample_qcal2 <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g1/pik),
median = weightedMedian(x = x, weights = g1/pik),
quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
results[[r]] <- rbind(sample_cal, sample_cal2, sample_qcal, sample_qcal2)
R <- 100
results <- list()
for (r in 1:R) {
set.seed(r)
if (r %% 10 == 0) print(r)
## standard balancing sampling
sample1 <- BalancedSampling::cube(prob = pop_data$pik,  x = X)
## without calibration
pop_data_sample1 <- copy(pop_data[sample1])
pop_data_sample1[, g:=1]
sample_cal <- pop_data_sample1[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## with calibration
g <- calib(Xs = model.matrix(~ x1 + x2, pop_data_sample1),
d = 1/pop_data_sample1$pik,
total = c(N, colSums(X)),
method = "raking")
pop_data_sample1[, g1:=g]
sample_cal2 <- pop_data_sample1[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g1/pik),
median = weightedMedian(x = x, weights = g1/pik),
quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## quantile balancing
sample2 <- BalancedSampling::cube(prob = pop_data$pik, x = cbind(X,Xs))
## without calibration
pop_data_sample2 <- copy(pop_data[sample2])
pop_data_sample2[, g:=1]
sample_qcal <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## with calibration
gcal <- joint_calib(formula_totals =  ~ x1 + x2,
formula_quantiles = ~ x1 + x2,
data = pop_data_sample2,
dweights = 1/pop_data_sample2$pik,
N = N,
pop_totals = colSums(X),
pop_quantiles = pop_quantiles,
method = "raking")
pop_data_sample2[, g1:=gcal$g]
sample_qcal2 <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g1/pik),
median = weightedMedian(x = x, weights = g1/pik),
quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
results[[r]] <- rbind(sample_cal, sample_cal2, sample_qcal, sample_qcal2)
}
results_all <- rbindlist(results, idcol = 'rep')
results_all[trues, on = c("variable", "type"), trues := true]
results_all <- results_all[!(type %in% c("quantile", "median") & variable %in% c("y21", "y22"))]
results_all[type != "total", .(m = (mean(value) - mean(trues))*100,
var = (var(value))*100,
rmse = (sqrt( (mean(value) - mean(trues))^2 + var(value)))*100),
keyby=.(type, variable, sample)] |>
melt(id.vars = c("type", "sample", "variable")) |>
transform(variable=paste(variable, variable.1, sep = "_"),
variable.1 = NULL) |>
transform(variable = factor(variable,
levels = c("y11_m", "y11_var", "y11_rmse",
"y12_m", "y12_var", "y12_rmse",
"y21_m", "y21_var", "y21_rmse",
"y22_m", "y22_var", "y22_rmse"))) |>
dcast(type + sample ~ variable, value.var = "value") |>
xtable() |>
print.xtable(include.rownames = F)
results_all[type == "total",
.(m = mean(value) - mean(trues),
var = var(value)/1000,
rmse = sqrt( (mean(value) - mean(trues))^2 + var(value))),
keyby=.(variable, sample)]
R <- 100
results <- list()
for (r in 1:R) {
set.seed(r)
if (r %% 10 == 0) print(r)
## standard balancing sampling
sample1 <- BalancedSampling::cube(prob = pop_data$pik,  x = X)
## without calibration
pop_data_sample1 <- copy(pop_data[sample1])
pop_data_sample1[, g:=1]
sample_cal <- pop_data_sample1[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## with calibration
gcal_x <- calib(Xs = model.matrix(~ x1 + x2, pop_data_sample1),
d = 1/pop_data_sample1$pik,
total = c(N, colSums(X)),
method = "raking")
pop_data_sample1[, g1:=gcal_x]
sample_cal2 <- pop_data_sample1[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g1/pik),
median = weightedMedian(x = x, weights = g1/pik),
quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## quantile balancing
sample2 <- BalancedSampling::cube(prob = pop_data$pik, x = cbind(X,Xs))
## without calibration
pop_data_sample2 <- copy(pop_data[sample2])
pop_data_sample2[, g:=1]
sample_qcal <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## with calibration
gcal <- joint_calib(formula_totals =  ~ x1 + x2,
formula_quantiles = ~ x1 + x2,
data = pop_data_sample2,
dweights = 1/pop_data_sample2$pik,
N = N,
pop_totals = colSums(X),
pop_quantiles = pop_quantiles,
method = "raking")
pop_data_sample2[, g1:=gcal$g]
sample_qcal2 <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g1/pik),
median = weightedMedian(x = x, weights = g1/pik),
quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
results[[r]] <- rbind(sample_cal, sample_cal2, sample_qcal, sample_qcal2)
}
results_all <- rbindlist(results, idcol = 'rep')
results_all[trues, on = c("variable", "type"), trues := true]
results_all <- results_all[!(type %in% c("quantile", "median") & variable %in% c("y21", "y22"))]
results_all[type == "total",
.(m = mean(value) - mean(trues),
var = var(value)/1000,
rmse = sqrt( (mean(value) - mean(trues))^2 + var(value))),
keyby=.(variable, sample)]
results_all[type != "total", .(m = (mean(value) - mean(trues))*100,
var = (var(value))*100,
rmse = (sqrt( (mean(value) - mean(trues))^2 + var(value)))*100),
keyby=.(type, variable, sample)] |>
melt(id.vars = c("type", "sample", "variable")) |>
transform(variable=paste(variable, variable.1, sep = "_"),
variable.1 = NULL) |>
transform(variable = factor(variable,
levels = c("y11_m", "y11_var", "y11_rmse",
"y12_m", "y12_var", "y12_rmse",
"y21_m", "y21_var", "y21_rmse",
"y22_m", "y22_var", "y22_rmse"))) |>
dcast(type + sample ~ variable, value.var = "value")
R <- 5000
results <- list()
for (r in 1:R) {
set.seed(r)
if (r %% 10 == 0) print(r)
## standard balancing sampling
sample1 <- BalancedSampling::cube(prob = pop_data$pik,  x = X)
## without calibration
pop_data_sample1 <- copy(pop_data[sample1])
pop_data_sample1[, g:=1]
sample_cal <- pop_data_sample1[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## with calibration
gcal_x <- calib(Xs = model.matrix(~ x1 + x2, pop_data_sample1),
d = 1/pop_data_sample1$pik,
total = c(N, colSums(X)),
method = "raking")
pop_data_sample1[, g1:=gcal_x]
sample_cal2 <- pop_data_sample1[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g1/pik),
median = weightedMedian(x = x, weights = g1/pik),
quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="cal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## quantile balancing
sample2 <- BalancedSampling::cube(prob = pop_data$pik, x = cbind(X,Xs))
## without calibration
pop_data_sample2 <- copy(pop_data[sample2])
pop_data_sample2[, g:=1]
sample_qcal <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g/pik),
median = weightedMedian(x = x, weights = g/pik),
quantile = weightedQuantile(x, weights = g/pik, probs = probs_est),
sum = sum(x*g/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-no"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
## with calibration
gcal <- joint_calib(formula_totals =  ~ x1 + x2,
formula_quantiles = ~ x1 + x2,
data = pop_data_sample2,
dweights = 1/pop_data_sample2$pik,
N = N,
pop_totals = colSums(X),
pop_quantiles = pop_quantiles,
method = "raking")
pop_data_sample2[, g1:=gcal$g]
sample_qcal2 <- pop_data_sample2[, lapply(.SD, function(x) c(mean = weighted.mean(x=x, w = g1/pik),
median = weightedMedian(x = x, weights = g1/pik),
quantile = weightedQuantile(x, weights = g1/pik, probs = probs_est),
sum = sum(x*g1/pik))),
.SDcols = vars_est][
, type:=c("mean", "median", "quantile", "total")][
, sample:="qcal-yes"] |>
melt(id.vars = c("type", "sample"), value.name = "value")
results[[r]] <- rbind(sample_cal, sample_cal2, sample_qcal, sample_qcal2)
}
results_all <- rbindlist(results, idcol = 'rep')
results_all[trues, on = c("variable", "type"), trues := true]
results_all <- results_all[!(type %in% c("quantile", "median") & variable %in% c("y21", "y22"))]
results_all[type != "total", .(m = (mean(value) - mean(trues))*100,
var = (var(value))*100,
rmse = (sqrt( (mean(value) - mean(trues))^2 + var(value)))*100),
keyby=.(type, variable, sample)] |>
melt(id.vars = c("type", "sample", "variable")) |>
transform(variable=paste(variable, variable.1, sep = "_"),
variable.1 = NULL) |>
transform(variable = factor(variable,
levels = c("y11_m", "y11_var", "y11_rmse",
"y12_m", "y12_var", "y12_rmse",
"y21_m", "y21_var", "y21_rmse",
"y22_m", "y22_var", "y22_rmse"))) |>
dcast(type + sample ~ variable, value.var = "value") |>
xtable() |>
print.xtable(include.rownames = F)
results_all[type != "total", .(m = (mean(value) - mean(trues))*100,
var = (var(value))*100,
rmse = (sqrt( (mean(value) - mean(trues))^2 + var(value)))*100),
keyby=.(type, variable, sample)] |>
melt(id.vars = c("type", "sample", "variable")) |>
transform(variable=paste(variable, variable.1, sep = "_"),
variable.1 = NULL) |>
transform(variable = factor(variable,
levels = c("y11_m", "y11_var", "y11_rmse",
"y12_m", "y12_var", "y12_rmse",
"y21_m", "y21_var", "y21_rmse",
"y22_m", "y22_var", "y22_rmse"))) |>
dcast(type + sample ~ variable, value.var = "value") |> View()
results_all[type == "total",
.(m = mean(value) - mean(trues),
var = var(value)/1000,
rmse = sqrt( (mean(value) - mean(trues))^2 + var(value))),
keyby=.(variable, sample)]
11357.495/7457.073
1832.162/1803.082
mean(y21)
mean(y22)
y22 <- rbinom(N,1,plogis(0.5*(x1-1.5)^2 + 0.5*x2^2 + alp))
mean(y21=2)
mean(y22)
